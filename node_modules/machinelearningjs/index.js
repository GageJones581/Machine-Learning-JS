const math = require('mathjs')

exports.printMsg = function () {
  console.log('This is a message from the demo package')
}

exports.Layer = class {
  constructor () {
    this.input = null
    this.output = null
  }

  forward (input) { }

  backward (outputGradient, learningRate) { }
}

exports.Dense = class extends exports.Layer {
  constructor (inputs, outputs) {
    super()
    this.weights = math.zeros(outputs, inputs)
    this.bias = math.zeros(outputs, 1)
  }

  forward (input) {
    this.input = input
    this.output = math.add(math.multiply(this.weights, this.input), this.bias)
    return this.output
  }

  backward (outputGradient, learningRate) {
    const weightsGradient = math.multiply(outputGradient, math.transpose(this.input))
    this.weights = math.subtract(this.weights, math.multiply(weightsGradient, learningRate))
    this.bias = math.subtract(this.bias, math.multiply(outputGradient, learningRate))
    return math.multiply(math.transpose(this.input), outputGradient)
  }
}

exports.Activation = class extends exports.Layer {
  constructor (activation, activationPrime) {
    super()
    this.activation = activation
    this.activationPrime = activationPrime
  }

  forward (input) {
    this.input = input
    this.output = this.activation(input)
    return this.output
  }

  backward (outputGradient, learningRate) {
    return math.dotMultiply(outputGradient, this.activationPrime(this.input))
  }
}

exports.Tanh = class extends exports.Activation {
  constructor () {
    const activation = x => math.tanh(x)
    const activationPrime = x => math.subtract(1, math.square(math.tanh(x)))
    super(activation, activationPrime)
  }
}

exports.mse = function (yTrue, yPred) {
  return math.mean(math.square(math.subtract(yPred, yTrue)))
}

exports.msePrime = function (yTrue, yPred) {
  console.log(math.size(yTrue))
  return math.divide(math.multiply(math.subtract(yTrue, yPred), 2), yTrue.length)
}

const zip = (a, b) => a.map((k, i) => [k, b[i]])

exports.Network = class {
  constructor (...layers) {
    this.layers = layers
  }

  predict (input) {
    let output = input
    for (const layer of this.layers) {
      output = layer.forward(output)
    }
    return output
  }

  train (xTrain, yTrain, loss, lossPrime, learningRate, epochs = 1000) {
    const errors = []
    const zippedXY = zip(xTrain, yTrain)
    for (let e = 0; e < epochs; e++) {
      let error = 0
      for (let i = 0; i < zippedXY.length; i++) {
        const x = math.resize(zippedXY[i][0], [zippedXY[i][0].length, 1])
        const y = math.resize(zippedXY[i][1], [zippedXY[i][1].length, 1])

        const output = this.predict(x)
        let grad = lossPrime(y, output)

        for (const layer of this.layers.reverse()) {
          grad = layer.backward(grad, learningRate)
        }
        this.layers.reverse()
      }
      error /= zippedXY.length()
      errors.push(error)
      console.log(error)
    }
    return errors
  }
}

const X = [[0, 0], [0, 1], [1, 0], [1, 1]]
const Y = [[0], [1], [1], [0]]

const network = new exports.Network(
  new exports.Dense(2, 2),
  new exports.Tanh(),
  new exports.Dense(2, 1),
  new exports.Tanh()
)
